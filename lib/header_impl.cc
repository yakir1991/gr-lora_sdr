// Only compile the following section when HAVE_CONFIG_H is defined. (inline comment notes: Check whether the build system provided a configuration header and include it if present.)
#ifdef HAVE_CONFIG_H  // Check whether the build system provided a configuration header and include it if present.
// Bring in declarations from "config.h". (inline comment notes: Bring in compile-time configuration macros generated by the build.)
#include "config.h"  // Bring in compile-time configuration macros generated by the build.
// Close the preceding conditional compilation block. (inline comment notes: End the optional config.h inclusion guard.)
#endif  // End the optional config.h inclusion guard.

// Bring in declarations from <gnuradio/io_signature.h>. (inline comment notes: Access GNU Radio helpers that describe block input and output signatures.)
#include <gnuradio/io_signature.h>  // Access GNU Radio helpers that describe block input and output signatures.
// Bring in declarations from "header_impl.h". (inline comment notes: Include the implementation header declaring the header_impl class.)
#include "header_impl.h"  // Include the implementation header declaring the header_impl class.

// Start namespace gr scope. (inline comment notes: Begin the top-level GNU Radio namespace that wraps all modules.)
namespace gr  // Begin the top-level GNU Radio namespace that wraps all modules.
// Open a new scope block.
{
    // Start namespace lora_sdr scope. (inline comment notes: Enter the LoRa SDR specific namespace to scope the block implementation.)
    namespace lora_sdr  // Enter the LoRa SDR specific namespace to scope the block implementation.
    // Open a new scope block.
    {

        // Specify the shared pointer typedef associated with header. (inline comment notes: Declare the return type for the factory function producing shared pointers to header blocks.)
        header::sptr  // Declare the return type for the factory function producing shared pointers to header blocks.
        // Define the r::make function. (inline comment notes: Provide a static helper that constructs a header block with the desired options.)
        header::make(bool impl_head, bool has_crc, uint8_t cr)  // Provide a static helper that constructs a header block with the desired options.
        // Open a new scope block.
        {
            // Return gnuradio::get_initial_sptr(new header_impl(impl_head, has_crc, cr)) to the caller. (inline comment notes: Allocate a new implementation instance and wrap it in a GNU Radio smart pointer helper.)
            return gnuradio::get_initial_sptr(new header_impl(impl_head, has_crc, cr));  // Allocate a new implementation instance and wrap it in a GNU Radio smart pointer helper.
        // Close the current scope block.
        }

        /*
     * The private constructor
     */
        // Define the l::header_impl function. (inline comment notes: Define the constructor, storing whether the header is implicit, contains a CRC, and the coding rate.)
        header_impl::header_impl(bool impl_head, bool has_crc, uint8_t cr)  // Define the constructor, storing whether the header is implicit, contains a CRC, and the coding rate.
            // Initialize base classes or members with gr::block("header",. (inline comment notes: Call the base class constructor naming the block "header" for identification.)
            : gr::block("header",  // Call the base class constructor naming the block "header" for identification.
                        // Specify parameter or initializer gr::io_signature::make(1, 1, sizeof(uint8_t)). (inline comment notes: Specify a single input stream of uint8_t symbols.)
                        gr::io_signature::make(1, 1, sizeof(uint8_t)),  // Specify a single input stream of uint8_t symbols.
                        // Define the e::make function. (inline comment notes: Specify a single output stream of uint8_t symbols.)
                        gr::io_signature::make(1, 1, sizeof(uint8_t)))  // Specify a single output stream of uint8_t symbols.
        // Open a new scope block.
        {
            // Assign m_cr to cr. (inline comment notes: Cache the coding rate that controls header redundancy.)
            m_cr = cr;  // Cache the coding rate that controls header redundancy.
            // Assign m_has_crc to has_crc. (inline comment notes: Remember whether the payload includes a CRC field to encode in the header bits.)
            m_has_crc = has_crc;  // Remember whether the payload includes a CRC field to encode in the header bits.
            // Assign m_impl_head to impl_head. (inline comment notes: Record whether an implicit header is used so we know if bytes must be generated.)
            m_impl_head = impl_head;  // Record whether an implicit header is used so we know if bytes must be generated.

            // Resize m_header to 5. (inline comment notes: Pre-allocate storage for the 5 header nibbles that the block produces for explicit headers.)
            m_header.resize(5);  // Pre-allocate storage for the 5 header nibbles that the block produces for explicit headers.

            // Call set_tag_propagation_policy with arguments (TPP_DONT). (inline comment notes: Stop GNU Radio from forwarding upstream tags automatically so we can manage them manually.)
            set_tag_propagation_policy(TPP_DONT);  // Stop GNU Radio from forwarding upstream tags automatically so we can manage them manually.
            // Resize m_tags to 3. (inline comment notes: Reserve three tag slots: length, payload text, and optional configuration.)
            m_tags.resize(3);  // Reserve three tag slots: length, payload text, and optional configuration.
            // Assign m_cnt_header_nibbles to 0. (inline comment notes: Reset the counter used to track how many header nibbles have been emitted.)
            m_cnt_header_nibbles = 0;  // Reset the counter used to track how many header nibbles have been emitted.
            // Assign m_has_config_tag to false. (inline comment notes: Flag that no configuration tag has been observed yet for the current frame.)
            m_has_config_tag = false;  // Flag that no configuration tag has been observed yet for the current frame.
        // Close the current scope block.
        }

        // Define the l::set_cr function. (inline comment notes: Provide a setter allowing runtime updates of the coding rate parameter.)
        void header_impl::set_cr(uint8_t cr){  // Provide a setter allowing runtime updates of the coding rate parameter.
            // Assign m_cr to cr. (inline comment notes: Store the new coding rate so future headers use the updated redundancy.)
            m_cr = cr;  // Store the new coding rate so future headers use the updated redundancy.
        // Close the current scope block.
        }

        // Define the l::get_cr function. (inline comment notes: Implement the accessor returning the currently configured coding rate value.)
        uint8_t header_impl::get_cr(){  // Implement the accessor returning the currently configured coding rate value.
            // Return m_cr to the caller. (inline comment notes: Report the stored coding rate so external code can query the setting.)
            return m_cr;  // Report the stored coding rate so external code can query the setting.
        // Close the current scope block.
        }

        /*
     * Our virtual destructor.
     */
        // Define the l::~header_impl function. (inline comment notes: Clean up the block when it is destroyed; nothing special is required here.)
        header_impl::~header_impl()  // Clean up the block when it is destroyed; nothing special is required here.
        // Open a new scope block.
        {
        // Close the current scope block.
        }

        // Execute void. (inline comment notes: Declare the return type for the forecast override.)
        void  // Declare the return type for the forecast override.
        // Define the l::forecast function. (inline comment notes: Tell the scheduler how many input items are needed for a desired output request.)
        header_impl::forecast(int noutput_items, gr_vector_int &ninput_items_required)  // Tell the scheduler how many input items are needed for a desired output request.
        // Open a new scope block.
        {
            // Assign ninput_items_required[0] to 1. (inline comment notes: Indicate that generating any amount of output requires at least one input symbol available.)
            ninput_items_required[0] = 1;  // Indicate that generating any amount of output requires at least one input symbol available.
        // Close the current scope block.
        }

        // Execute int. (inline comment notes: State that general_work returns an integer indicating the number of output items produced.)
        int  // State that general_work returns an integer indicating the number of output items produced.
        // Specify parameter or initializer header_impl::general_work(int noutput_items. (inline comment notes: Provide the scheduler with the maximum number of items the caller wants produced.)
        header_impl::general_work(int noutput_items,  // Provide the scheduler with the maximum number of items the caller wants produced.
                                  // Specify parameter or initializer gr_vector_int &ninput_items. (inline comment notes: Report how many new items are available on each input stream.)
                                  gr_vector_int &ninput_items,  // Report how many new items are available on each input stream.
                                  // Specify parameter or initializer gr_vector_const_void_star &input_items. (inline comment notes: Provide access to the raw input buffers for processing.)
                                  gr_vector_const_void_star &input_items,  // Provide access to the raw input buffers for processing.
                                  // Execute gr_vector_void_star &output_items). (inline comment notes: Provide access to the output buffers where results must be stored.)
                                  gr_vector_void_star &output_items)  // Provide access to the output buffers where results must be stored.
        // Open a new scope block.
        {
            // Assign const uint8_t *in to (const uint8_t *)input_items[0]. (inline comment notes: Interpret the first input buffer as an array of byte-sized symbols.)
            const uint8_t *in = (const uint8_t *)input_items[0];  // Interpret the first input buffer as an array of byte-sized symbols.
            // Assign uint8_t *out to (uint8_t *)output_items[0]. (inline comment notes: Interpret the output buffer as mutable byte-sized symbols.)
            uint8_t *out = (uint8_t *)output_items[0];  // Interpret the output buffer as mutable byte-sized symbols.
            // Assign int nitems_to_process to std::min(ninput_items[0], noutput_items). (inline comment notes: Limit work to the smaller of available input or requested output items.)
            int nitems_to_process = std::min(ninput_items[0], noutput_items);  // Limit work to the smaller of available input or requested output items.
            // Assign int out_offset to 0. (inline comment notes: Track how many items were consumed by header generation before copying payload symbols.)
            int out_offset = 0;  // Track how many items were consumed by header generation before copying payload symbols.

            // read tags
            // Declare std::vector<tag_t> tags. (inline comment notes: Prepare a container to receive GNU Radio tag metadata found on the input stream.)
            std::vector<tag_t> tags;  // Prepare a container to receive GNU Radio tag metadata found on the input stream.
            // Call get_tags_in_window with arguments (tags, 0, 0, ninput_items[0], pmt::string_to_symbol("frame_len")). (inline comment notes: Collect any frame length tags present in the current window.)
            get_tags_in_window(tags, 0, 0, ninput_items[0], pmt::string_to_symbol("frame_len"));  // Collect any frame length tags present in the current window.
            // Branch when condition (tags.size()) evaluates to true. (inline comment notes: Only process tag metadata when at least one relevant tag was found.)
            if (tags.size())  // Only process tag metadata when at least one relevant tag was found.
            // Open a new scope block.
            {
                // Branch when condition (tags[0].offset != nitems_read(0)) evaluates to true. (inline comment notes: Check whether the first tag belongs to a future sample rather than the current read head.)
                if (tags[0].offset != nitems_read(0))  // Check whether the first tag belongs to a future sample rather than the current read head.
                    // Assign nitems_to_process to std::min(tags[0].offset - nitems_read(0), (uint64_t)noutput_items). (inline comment notes: Limit work so we stop before reaching the next tag boundary.)
                    nitems_to_process = std::min(tags[0].offset - nitems_read(0), (uint64_t)noutput_items);  // Limit work so we stop before reaching the next tag boundary.
                // Handle the alternative branch when previous conditions fail. (inline comment notes: Otherwise the tag aligns with the current sample and we can handle frame setup now.)
                else  // Otherwise the tag aligns with the current sample and we can handle frame setup now.
                // Open a new scope block.
                {
                    // Branch when condition (tags.size() >= 2) evaluates to true. (inline comment notes: 2  // When two tags are present, the second marks the payload boundary.)
                    if (tags.size() >= 2) //2  // When two tags are present, the second marks the payload boundary.
                        // Assign nitems_to_process to std::min(tags[1].offset - tags[0].offset, (uint64_t)noutput_items). (inline comment notes: Restrict processing to the frame region between the first two tags.)
                        nitems_to_process = std::min(tags[1].offset - tags[0].offset, (uint64_t)noutput_items);  // Restrict processing to the frame region between the first two tags.

                    // Assign m_payload_len to int(pmt::to_long(tags[0].value) / 2). (inline comment notes: Convert the stored nibble-based length into a byte count for header encoding.)
                    m_payload_len = int(pmt::to_long(tags[0].value) / 2);  // Convert the stored nibble-based length into a byte count for header encoding.
                    //pass tags downstream
                    // Assign tags[0].offset to nitems_written(0). (inline comment notes: Shift the frame length tag so it aligns with the next output sample index.)
                    tags[0].offset = nitems_written(0);  // Shift the frame length tag so it aligns with the next output sample index.
                    // Assign tags[0].value to pmt::from_long(m_payload_len * 2 + (m_impl_head ? 0 : 5)). (inline comment notes: 5 being the explicit header length  // Update the length tag to describe the total symbols including generated header nibbles when explicit mode is used.)
                    tags[0].value = pmt::from_long(m_payload_len * 2 + (m_impl_head ? 0 : 5)); // 5 being the explicit header length  // Update the length tag to describe the total symbols including generated header nibbles when explicit mode is used.
                    // Assign m_tags[0] to tags[0]. (inline comment notes: Cache the adjusted length tag for later insertion on the output stream.)
                    m_tags[0] = tags[0];  // Cache the adjusted length tag for later insertion on the output stream.

                    // Call get_tags_in_window with arguments (tags, 0, 0, 1, pmt::string_to_symbol("payload_str")). (inline comment notes: Search for an optional payload string tag accompanying the frame start.)
                    get_tags_in_window(tags, 0, 0, 1, pmt::string_to_symbol("payload_str"));  // Search for an optional payload string tag accompanying the frame start.
                    // Assign tags[0].offset to nitems_written(0). (inline comment notes: Align the payload string tag with the output write index.)
                    tags[0].offset = nitems_written(0);  // Align the payload string tag with the output write index.
                    // Assign m_cnt_nibbles to 0. (inline comment notes: Reset the nibble counter so the next frame starts counting from zero.)
                    m_cnt_nibbles = 0;  // Reset the nibble counter so the next frame starts counting from zero.

                    // Assign m_tags[1] to tags[0]. (inline comment notes: Store the payload string tag so it can be reattached once the header is emitted.)
                    m_tags[1] = tags[0];  // Store the payload string tag so it can be reattached once the header is emitted.
                    // Call get_tags_in_window with arguments (tags, 0, 0, 1, pmt::string_to_symbol("configuration")). (inline comment notes: Look for a configuration tag carrying dynamic modulation settings.)
                    get_tags_in_window(tags, 0, 0, 1, pmt::string_to_symbol("configuration"));  // Look for a configuration tag carrying dynamic modulation settings.
                    // Branch when condition (tags.size() > 0) evaluates to true. (inline comment notes: Only adjust configuration if such a tag was actually found.)
                    if(tags.size() > 0)  // Only adjust configuration if such a tag was actually found.
                    // Open a new scope block.
                    {
                        // Assign tags[0].offset to nitems_written(0). (inline comment notes: Align the configuration tag offset with the output stream location.)
                        tags[0].offset = nitems_written(0);  // Align the configuration tag offset with the output stream location.
                        // Assign m_tags[2] to tags[0]. (inline comment notes: Cache the configuration tag so it can be forwarded alongside the frame start.)
                        m_tags[2] = tags[0];  // Cache the configuration tag so it can be forwarded alongside the frame start.

                        // Assign pmt::pmt_t err to pmt::string_to_symbol("error"). (inline comment notes: Create a symbol used as a default return when dictionary lookups fail.)
                        pmt::pmt_t err = pmt::string_to_symbol("error");  // Create a symbol used as a default return when dictionary lookups fail.
                        // Assign int new_cr to pmt::to_long(pmt::dict_ref(tags[0].value, pmt::string_to_symbol("cr"), err)). (inline comment notes: Extract the coding rate field from the configuration dictionary if present.)
                        int new_cr = pmt::to_long(pmt::dict_ref(tags[0].value, pmt::string_to_symbol("cr"), err));  // Extract the coding rate field from the configuration dictionary if present.
                        // Branch when condition (new_cr != m_cr) evaluates to true. (inline comment notes: Check whether the extracted coding rate differs from the currently stored value.)
                        if (new_cr != m_cr) {  // Check whether the extracted coding rate differs from the currently stored value.
                            // Assign m_cr to new_cr. (inline comment notes: Update the member variable so subsequent headers use the most recent coding rate.)
                            m_cr = new_cr;  // Update the member variable so subsequent headers use the most recent coding rate.
                        // Close the current scope block.
                        }
                        // Assign m_has_config_tag to true. (inline comment notes: Remember that a configuration tag should be forwarded with the frame.)
                        m_has_config_tag = true;  // Remember that a configuration tag should be forwarded with the frame.
                    // Close the current scope block.
                    }
                // Close the current scope block.
                }
            // Close the current scope block.
            }


            // Branch when condition (m_cnt_nibbles == 0 && !m_impl_head) evaluates to true. (inline comment notes: When starting a frame in explicit header mode, generate header symbols.)
            if (m_cnt_nibbles == 0 && !m_impl_head)  // When starting a frame in explicit header mode, generate header symbols.
            // Open a new scope block.
            {

                // Branch when condition (m_cnt_header_nibbles == 0) evaluates to true. (inline comment notes: Only build the header contents once at the beginning of the frame.)
                if (m_cnt_header_nibbles == 0)  // Only build the header contents once at the beginning of the frame.
                // Open a new scope block.
                {
                    //create header
                    //payload length
                    // Assign m_header[0] to (m_payload_len >> 4). (inline comment notes: Put the high-order nibble of the payload length into the first header position.)
                    m_header[0] = (m_payload_len >> 4);  // Put the high-order nibble of the payload length into the first header position.
                    // Assign m_header[1] to (m_payload_len & 0x0F). (inline comment notes: Put the low-order nibble of the payload length into the second header position.)
                    m_header[1] = (m_payload_len & 0x0F);  // Put the low-order nibble of the payload length into the second header position.

                    //coding rate and has_crc
                    // Assign m_header[2] to ((m_cr << 1) | m_has_crc). (inline comment notes: Pack the coding rate and CRC present flag into the third header nibble.)
                    m_header[2] = ((m_cr << 1) | m_has_crc);  // Pack the coding rate and CRC present flag into the third header nibble.

                    //header checksum
                    // Assign bool c4 to (m_header[0] & 0b1000) >> 3 ^ (m_header[0] & 0b0100) >> 2 ^ (m_header[0] & 0b0010) >> 1 ^ (m_header[0] & 0b0001). (inline comment notes: Compute the first parity bit using the generator matrix specified by LoRa.)
                    bool c4 = (m_header[0] & 0b1000) >> 3 ^ (m_header[0] & 0b0100) >> 2 ^ (m_header[0] & 0b0010) >> 1 ^ (m_header[0] & 0b0001);  // Compute the first parity bit using the generator matrix specified by LoRa.
                    // Assign bool c3 to (m_header[0] & 0b1000) >> 3 ^ (m_header[1] & 0b1000) >> 3 ^ (m_header[1] & 0b0100) >> 2 ^ (m_header[1] & 0b0010) >> 1 ^ (m_header[2] & 0b0001). (inline comment notes: Compute the second parity bit covering length and configuration bits.)
                    bool c3 = (m_header[0] & 0b1000) >> 3 ^ (m_header[1] & 0b1000) >> 3 ^ (m_header[1] & 0b0100) >> 2 ^ (m_header[1] & 0b0010) >> 1 ^ (m_header[2] & 0b0001);  // Compute the second parity bit covering length and configuration bits.
                    // Assign bool c2 to (m_header[0] & 0b0100) >> 2 ^ (m_header[1] & 0b1000) >> 3 ^ (m_header[1] & 0b0001) ^ (m_header[2] & 0b1000) >> 3 ^ (m_header[2] & 0b0010) >> 1. (inline comment notes: Compute the third parity bit using the LoRa parity relations.)
                    bool c2 = (m_header[0] & 0b0100) >> 2 ^ (m_header[1] & 0b1000) >> 3 ^ (m_header[1] & 0b0001) ^ (m_header[2] & 0b1000) >> 3 ^ (m_header[2] & 0b0010) >> 1;  // Compute the third parity bit using the LoRa parity relations.
                    // Assign bool c1 to (m_header[0] & 0b0010) >> 1 ^ (m_header[1] & 0b0100) >> 2 ^ (m_header[1] & 0b0001) ^ (m_header[2] & 0b0100) >> 2 ^ (m_header[2] & 0b0010) >> 1 ^ (m_header[2] & 0b0001). (inline comment notes: Compute the fourth parity bit for the header checksum nibble.)
                    bool c1 = (m_header[0] & 0b0010) >> 1 ^ (m_header[1] & 0b0100) >> 2 ^ (m_header[1] & 0b0001) ^ (m_header[2] & 0b0100) >> 2 ^ (m_header[2] & 0b0010) >> 1 ^ (m_header[2] & 0b0001);  // Compute the fourth parity bit for the header checksum nibble.
                    // Assign bool c0 to (m_header[0] & 0b0001) ^ (m_header[1] & 0b0010) >> 1 ^ (m_header[2] & 0b1000) >> 3 ^ (m_header[2] & 0b0100) >> 2 ^ (m_header[2] & 0b0010) >> 1 ^ (m_header[2] & 0b0001). (inline comment notes: Compute the final parity bit as required by LoRa specification.)
                    bool c0 = (m_header[0] & 0b0001) ^ (m_header[1] & 0b0010) >> 1 ^ (m_header[2] & 0b1000) >> 3 ^ (m_header[2] & 0b0100) >> 2 ^ (m_header[2] & 0b0010) >> 1 ^ (m_header[2] & 0b0001);  // Compute the final parity bit as required by LoRa specification.

                    // Assign m_header[3] to c4. (inline comment notes: Store the MSB parity bit as a standalone header nibble.)
                    m_header[3] = c4;  // Store the MSB parity bit as a standalone header nibble.
                    // Assign m_header[4] to c3 << 3 | c2 << 2 | c1 << 1 | c0. (inline comment notes: Pack the remaining parity bits into the final checksum nibble.)
                    m_header[4] = c3 << 3 | c2 << 2 | c1 << 1 | c0;  // Pack the remaining parity bits into the final checksum nibble.

                    //add tag
                    // Call add_item_tag with arguments (0, m_tags[0]). (inline comment notes: Emit the updated frame length tag aligned with the outgoing stream.)
                    add_item_tag(0, m_tags[0]);  // Emit the updated frame length tag aligned with the outgoing stream.
                    // Call add_item_tag with arguments (0, m_tags[1]). (inline comment notes: Emit the payload string tag for downstream consumers.)
                    add_item_tag(0, m_tags[1]);  // Emit the payload string tag for downstream consumers.
                    // Branch when condition (m_has_config_tag) add_item_tag(0, m_tags[2]) evaluates to true. (inline comment notes: Forward the configuration tag when one was captured on the input.)
                    if(m_has_config_tag) add_item_tag(0, m_tags[2]);  // Forward the configuration tag when one was captured on the input.
                    // Assign m_has_config_tag to false. (inline comment notes: Reset the configuration tag flag for the next frame.)
                    m_has_config_tag = false;  // Reset the configuration tag flag for the next frame.
                // Close the current scope block.
                }

                // Iterate with loop parameters (int i = 0; i < nitems_to_process; i++). (inline comment notes: Iterate across the available work window to output header symbols first.)
                for (int i = 0; i < nitems_to_process; i++)  // Iterate across the available work window to output header symbols first.
                // Open a new scope block.
                {
                    // Branch when condition (m_cnt_header_nibbles < 5) evaluates to true. (inline comment notes: While there are still header nibbles to emit, provide them sequentially.)
                    if (m_cnt_header_nibbles < 5)  // While there are still header nibbles to emit, provide them sequentially.
                    // Open a new scope block.
                    {
                        // Assign out[i] to m_header[m_cnt_header_nibbles]. (inline comment notes: Copy the current header nibble into the output buffer.)
                        out[i] = m_header[m_cnt_header_nibbles];  // Copy the current header nibble into the output buffer.
                        // Increment m_cnt_header_nibbles. (inline comment notes: Advance the header nibble counter so the next iteration uses the following nibble.)
                        m_cnt_header_nibbles++;  // Advance the header nibble counter so the next iteration uses the following nibble.
                        // Increment out_offset. (inline comment notes: Increase the offset to record that header bytes consumed part of the output window.)
                        out_offset++;  // Increase the offset to record that header bytes consumed part of the output window.
                    // Close the current scope block.
                    }
                    // Handle the alternative branch when previous conditions fail. (inline comment notes: Once all header nibbles are emitted, stop filling header data.)
                    else  // Once all header nibbles are emitted, stop filling header data.
                    // Open a new scope block.
                    {
                        // Exit the nearest enclosing loop or switch. (inline comment notes: Exit the loop so payload symbols are handled afterwards.)
                        break;  // Exit the loop so payload symbols are handled afterwards.
                    // Close the current scope block.
                    }

                // Close the current scope block.
                }
            // Close the current scope block.
            }
            // Branch when condition (m_impl_head && m_cnt_nibbles == 0) evaluates to true. (inline comment notes: For implicit header mode, simply forward relevant tags when a new frame begins.)
            if (m_impl_head && m_cnt_nibbles == 0)  // For implicit header mode, simply forward relevant tags when a new frame begins.
            // Open a new scope block.
            {
                // Call add_item_tag with arguments (0, m_tags[0]). (inline comment notes: Forward the frame length tag unchanged since no header bytes are generated.)
                add_item_tag(0, m_tags[0]);  // Forward the frame length tag unchanged since no header bytes are generated.
                // Call add_item_tag with arguments (0, m_tags[1]). (inline comment notes: Forward the payload description tag for downstream inspection.)
                add_item_tag(0, m_tags[1]);  // Forward the payload description tag for downstream inspection.
                // Branch when condition (m_has_config_tag) add_item_tag(0, m_tags[2]) evaluates to true. (inline comment notes: Propagate configuration information if available.)
                if(m_has_config_tag) add_item_tag(0, m_tags[2]);  // Propagate configuration information if available.
                // Assign m_has_config_tag to false. (inline comment notes: Clear the configuration tag flag because the tag has been sent.)
                m_has_config_tag = false;  // Clear the configuration tag flag because the tag has been sent.
            // Close the current scope block.
            }
            // Iterate with loop parameters (int i = out_offset; i < nitems_to_process; i++). (inline comment notes: Copy the remaining payload symbols after accounting for any header bytes.)
            for (int i = out_offset; i < nitems_to_process; i++)  // Copy the remaining payload symbols after accounting for any header bytes.
            // Open a new scope block.
            {
                // Assign out[i] to in[i - out_offset]. (inline comment notes: Move data from the input stream into the output buffer, adjusting for header offset.)
                out[i] = in[i - out_offset];  // Move data from the input stream into the output buffer, adjusting for header offset.
                // Increment m_cnt_nibbles. (inline comment notes: Count how many payload nibbles have been forwarded in this frame.)
                m_cnt_nibbles++;  // Count how many payload nibbles have been forwarded in this frame.
                // Assign m_cnt_header_nibbles to 0. (inline comment notes: Reset the header counter so the next frame will regenerate header data if needed.)
                m_cnt_header_nibbles = 0;  // Reset the header counter so the next frame will regenerate header data if needed.
            // Close the current scope block.
            }
            // Call consume_each with arguments (nitems_to_process - out_offset). (inline comment notes: Inform the scheduler that we only consumed payload items, not the artificially inserted header.)
            consume_each(nitems_to_process - out_offset);  // Inform the scheduler that we only consumed payload items, not the artificially inserted header.
            // Return nitems_to_process to the caller. (inline comment notes: Tell GNU Radio how many output items were actually produced.)
            return nitems_to_process;  // Tell GNU Radio how many output items were actually produced.
        // Close the current scope block.
        }

    // Close the current scope and emit the trailing comment. (inline comment notes: Close the lora_sdr namespace scope opened earlier.)
    } /* namespace lora */  // Close the lora_sdr namespace scope opened earlier.
// Close the current scope and emit the trailing comment. (inline comment notes: Close the top-level GNU Radio namespace scope.)
} /* namespace gr */  // Close the top-level GNU Radio namespace scope.
