#ifdef HAVE_CONFIG_H  // Check whether the build system provided a configuration header and include it if present.
#include "config.h"  // Bring in compile-time configuration macros generated by the build.
#endif  // End the optional config.h inclusion guard.

#include <gnuradio/io_signature.h>  // Access GNU Radio helpers that describe block input and output signatures.
#include "header_impl.h"  // Include the implementation header declaring the header_impl class.

namespace gr  // Begin the top-level GNU Radio namespace that wraps all modules.
{
    namespace lora_sdr  // Enter the LoRa SDR specific namespace to scope the block implementation.
    {

        header::sptr  // Declare the return type for the factory function producing shared pointers to header blocks.
        header::make(bool impl_head, bool has_crc, uint8_t cr)  // Provide a static helper that constructs a header block with the desired options.
        {
            return gnuradio::get_initial_sptr(new header_impl(impl_head, has_crc, cr));  // Allocate a new implementation instance and wrap it in a GNU Radio smart pointer helper.
        }

        /*
     * The private constructor
     */
        header_impl::header_impl(bool impl_head, bool has_crc, uint8_t cr)  // Define the constructor, storing whether the header is implicit, contains a CRC, and the coding rate.
            : gr::block("header",  // Call the base class constructor naming the block "header" for identification.
                        gr::io_signature::make(1, 1, sizeof(uint8_t)),  // Specify a single input stream of uint8_t symbols.
                        gr::io_signature::make(1, 1, sizeof(uint8_t)))  // Specify a single output stream of uint8_t symbols.
        {
            m_cr = cr;  // Cache the coding rate that controls header redundancy.
            m_has_crc = has_crc;  // Remember whether the payload includes a CRC field to encode in the header bits.
            m_impl_head = impl_head;  // Record whether an implicit header is used so we know if bytes must be generated.

            m_header.resize(5);  // Pre-allocate storage for the 5 header nibbles that the block produces for explicit headers.

            set_tag_propagation_policy(TPP_DONT);  // Stop GNU Radio from forwarding upstream tags automatically so we can manage them manually.
            m_tags.resize(3);  // Reserve three tag slots: length, payload text, and optional configuration.
            m_cnt_header_nibbles = 0;  // Reset the counter used to track how many header nibbles have been emitted.
            m_has_config_tag = false;  // Flag that no configuration tag has been observed yet for the current frame.
        }

        void header_impl::set_cr(uint8_t cr){  // Provide a setter allowing runtime updates of the coding rate parameter.
            m_cr = cr;  // Store the new coding rate so future headers use the updated redundancy.
        }

        uint8_t header_impl::get_cr(){  // Implement the accessor returning the currently configured coding rate value.
            return m_cr;  // Report the stored coding rate so external code can query the setting.
        }

        /*
     * Our virtual destructor.
     */
        header_impl::~header_impl()  // Clean up the block when it is destroyed; nothing special is required here.
        {
        }

        void  // Declare the return type for the forecast override.
        header_impl::forecast(int noutput_items, gr_vector_int &ninput_items_required)  // Tell the scheduler how many input items are needed for a desired output request.
        {
            ninput_items_required[0] = 1;  // Indicate that generating any amount of output requires at least one input symbol available.
        }

        int  // State that general_work returns an integer indicating the number of output items produced.
        header_impl::general_work(int noutput_items,  // Provide the scheduler with the maximum number of items the caller wants produced.
                                  gr_vector_int &ninput_items,  // Report how many new items are available on each input stream.
                                  gr_vector_const_void_star &input_items,  // Provide access to the raw input buffers for processing.
                                  gr_vector_void_star &output_items)  // Provide access to the output buffers where results must be stored.
        {
            const uint8_t *in = (const uint8_t *)input_items[0];  // Interpret the first input buffer as an array of byte-sized symbols.
            uint8_t *out = (uint8_t *)output_items[0];  // Interpret the output buffer as mutable byte-sized symbols.
            int nitems_to_process = std::min(ninput_items[0], noutput_items);  // Limit work to the smaller of available input or requested output items.
            int out_offset = 0;  // Track how many items were consumed by header generation before copying payload symbols.

            // read tags
            std::vector<tag_t> tags;  // Prepare a container to receive GNU Radio tag metadata found on the input stream.
            get_tags_in_window(tags, 0, 0, ninput_items[0], pmt::string_to_symbol("frame_len"));  // Collect any frame length tags present in the current window.
            if (tags.size())  // Only process tag metadata when at least one relevant tag was found.
            {
                if (tags[0].offset != nitems_read(0))  // Check whether the first tag belongs to a future sample rather than the current read head.
                    nitems_to_process = std::min(tags[0].offset - nitems_read(0), (uint64_t)noutput_items);  // Limit work so we stop before reaching the next tag boundary.
                else  // Otherwise the tag aligns with the current sample and we can handle frame setup now.
                {
                    if (tags.size() >= 2) //2  // When two tags are present, the second marks the payload boundary.
                        nitems_to_process = std::min(tags[1].offset - tags[0].offset, (uint64_t)noutput_items);  // Restrict processing to the frame region between the first two tags.

                    m_payload_len = int(pmt::to_long(tags[0].value) / 2);  // Convert the stored nibble-based length into a byte count for header encoding.
                    //pass tags downstream
                    tags[0].offset = nitems_written(0);  // Shift the frame length tag so it aligns with the next output sample index.
                    tags[0].value = pmt::from_long(m_payload_len * 2 + (m_impl_head ? 0 : 5)); // 5 being the explicit header length  // Update the length tag to describe the total symbols including generated header nibbles when explicit mode is used.
                    m_tags[0] = tags[0];  // Cache the adjusted length tag for later insertion on the output stream.

                    get_tags_in_window(tags, 0, 0, 1, pmt::string_to_symbol("payload_str"));  // Search for an optional payload string tag accompanying the frame start.
                    tags[0].offset = nitems_written(0);  // Align the payload string tag with the output write index.
                    m_cnt_nibbles = 0;  // Reset the nibble counter so the next frame starts counting from zero.

                    m_tags[1] = tags[0];  // Store the payload string tag so it can be reattached once the header is emitted.
                    get_tags_in_window(tags, 0, 0, 1, pmt::string_to_symbol("configuration"));  // Look for a configuration tag carrying dynamic modulation settings.
                    if(tags.size() > 0)  // Only adjust configuration if such a tag was actually found.
                    {
                        tags[0].offset = nitems_written(0);  // Align the configuration tag offset with the output stream location.
                        m_tags[2] = tags[0];  // Cache the configuration tag so it can be forwarded alongside the frame start.

                        pmt::pmt_t err = pmt::string_to_symbol("error");  // Create a symbol used as a default return when dictionary lookups fail.
                        int new_cr = pmt::to_long(pmt::dict_ref(tags[0].value, pmt::string_to_symbol("cr"), err));  // Extract the coding rate field from the configuration dictionary if present.
                        if (new_cr != m_cr) {  // Check whether the extracted coding rate differs from the currently stored value.
                            m_cr = new_cr;  // Update the member variable so subsequent headers use the most recent coding rate.
                        }
                        m_has_config_tag = true;  // Remember that a configuration tag should be forwarded with the frame.
                    }
                }
            }


            if (m_cnt_nibbles == 0 && !m_impl_head)  // When starting a frame in explicit header mode, generate header symbols.
            {

                if (m_cnt_header_nibbles == 0)  // Only build the header contents once at the beginning of the frame.
                {
                    //create header
                    //payload length
                    m_header[0] = (m_payload_len >> 4);  // Put the high-order nibble of the payload length into the first header position.
                    m_header[1] = (m_payload_len & 0x0F);  // Put the low-order nibble of the payload length into the second header position.

                    //coding rate and has_crc
                    m_header[2] = ((m_cr << 1) | m_has_crc);  // Pack the coding rate and CRC present flag into the third header nibble.

                    //header checksum
                    bool c4 = (m_header[0] & 0b1000) >> 3 ^ (m_header[0] & 0b0100) >> 2 ^ (m_header[0] & 0b0010) >> 1 ^ (m_header[0] & 0b0001);  // Compute the first parity bit using the generator matrix specified by LoRa.
                    bool c3 = (m_header[0] & 0b1000) >> 3 ^ (m_header[1] & 0b1000) >> 3 ^ (m_header[1] & 0b0100) >> 2 ^ (m_header[1] & 0b0010) >> 1 ^ (m_header[2] & 0b0001);  // Compute the second parity bit covering length and configuration bits.
                    bool c2 = (m_header[0] & 0b0100) >> 2 ^ (m_header[1] & 0b1000) >> 3 ^ (m_header[1] & 0b0001) ^ (m_header[2] & 0b1000) >> 3 ^ (m_header[2] & 0b0010) >> 1;  // Compute the third parity bit using the LoRa parity relations.
                    bool c1 = (m_header[0] & 0b0010) >> 1 ^ (m_header[1] & 0b0100) >> 2 ^ (m_header[1] & 0b0001) ^ (m_header[2] & 0b0100) >> 2 ^ (m_header[2] & 0b0010) >> 1 ^ (m_header[2] & 0b0001);  // Compute the fourth parity bit for the header checksum nibble.
                    bool c0 = (m_header[0] & 0b0001) ^ (m_header[1] & 0b0010) >> 1 ^ (m_header[2] & 0b1000) >> 3 ^ (m_header[2] & 0b0100) >> 2 ^ (m_header[2] & 0b0010) >> 1 ^ (m_header[2] & 0b0001);  // Compute the final parity bit as required by LoRa specification.

                    m_header[3] = c4;  // Store the MSB parity bit as a standalone header nibble.
                    m_header[4] = c3 << 3 | c2 << 2 | c1 << 1 | c0;  // Pack the remaining parity bits into the final checksum nibble.

                    //add tag
                    add_item_tag(0, m_tags[0]);  // Emit the updated frame length tag aligned with the outgoing stream.
                    add_item_tag(0, m_tags[1]);  // Emit the payload string tag for downstream consumers.
                    if(m_has_config_tag) add_item_tag(0, m_tags[2]);  // Forward the configuration tag when one was captured on the input.
                    m_has_config_tag = false;  // Reset the configuration tag flag for the next frame.
                }

                for (int i = 0; i < nitems_to_process; i++)  // Iterate across the available work window to output header symbols first.
                {
                    if (m_cnt_header_nibbles < 5)  // While there are still header nibbles to emit, provide them sequentially.
                    {
                        out[i] = m_header[m_cnt_header_nibbles];  // Copy the current header nibble into the output buffer.
                        m_cnt_header_nibbles++;  // Advance the header nibble counter so the next iteration uses the following nibble.
                        out_offset++;  // Increase the offset to record that header bytes consumed part of the output window.
                    }
                    else  // Once all header nibbles are emitted, stop filling header data.
                    {
                        break;  // Exit the loop so payload symbols are handled afterwards.
                    }

                }
            }
            if (m_impl_head && m_cnt_nibbles == 0)  // For implicit header mode, simply forward relevant tags when a new frame begins.
            {
                add_item_tag(0, m_tags[0]);  // Forward the frame length tag unchanged since no header bytes are generated.
                add_item_tag(0, m_tags[1]);  // Forward the payload description tag for downstream inspection.
                if(m_has_config_tag) add_item_tag(0, m_tags[2]);  // Propagate configuration information if available.
                m_has_config_tag = false;  // Clear the configuration tag flag because the tag has been sent.
            }
            for (int i = out_offset; i < nitems_to_process; i++)  // Copy the remaining payload symbols after accounting for any header bytes.
            {
                out[i] = in[i - out_offset];  // Move data from the input stream into the output buffer, adjusting for header offset.
                m_cnt_nibbles++;  // Count how many payload nibbles have been forwarded in this frame.
                m_cnt_header_nibbles = 0;  // Reset the header counter so the next frame will regenerate header data if needed.
            }
            consume_each(nitems_to_process - out_offset);  // Inform the scheduler that we only consumed payload items, not the artificially inserted header.
            return nitems_to_process;  // Tell GNU Radio how many output items were actually produced.
        }

    } /* namespace lora */  // Close the lora_sdr namespace scope opened earlier.
} /* namespace gr */  // Close the top-level GNU Radio namespace scope.
